// !!!
// Пришлось изменить логику ответов из-за урезанного openai api Яндекса и
// необходимости совместимости с этим openai api в случае прочих провайдеров инференса.
// А вот прерывание генерации не требует изменений, просто клиенту надо отменить вызов и
// сервис это заметит через контекст.

// Версия синтаксиса Protocol Buffers (используется proto3 - современная версия)
syntax = "proto3";

// Пакет определяет пространство имен для типов данных, определенных в этом файле.
// Это помогает избежать конфликтов имен при использовании нескольких proto-файлов.
package llm;

// Импорт стандартного типа Empty из библиотеки Google Protobuf.
// Empty используется когда RPC-методу не нужно передавать или возвращать данные.
import "google/protobuf/empty.proto";

// Опция для генерации Go-кода: указывает путь к пакету в Go-проекте.
option go_package = "proto/llm";

// ============================================================================
// СТРУКТУРЫ ДАННЫХ (MESSAGE)
// ============================================================================

// Message представляет одно сообщение в диалоге.
// В протобуфах message - это hash-ссылка на сообщение в kv store.
message Message {
  string hash = 1;
}

// MarkdownUrl содержит URL и оригинальное имя markdown документа.
message MarkdownUrl {
  string original_name = 1;  // Название оригинального документа
  string url = 2;            // URL markdown версии документа
}

// NewMessageRequest - запрос на отправку нового сообщения в чат с языковой моделью.
// Этот тип используется клиентом для передачи данных на сервер.
// NewMessageRequest - запрос на отправку нового сообщения в чат с языковой моделью.
// Поддерживает два режима передачи:
// 1) Текстовое сообщение — клиент отправляет один пакет с текстом.
// 2) Аудиофайл (строго mp3) — клиент передаёт поток чанков (stream).
// При использовании аудио-потока клиент отправляет несколько сообщений NewMessageRequest,
// каждое из которых содержит поле mp3_chunk с частью байтов файла. Сервер считает все
// чанки, собирает их и при завершении обработки отвечает обычным потоком NewMessageResponse.
message NewMessageRequest {
  // Текстовое сообщение (одиночное)
  string msg = 1;

  // История предыдущих сообщений
  repeated Message history = 2;
  optional string text2text_model = 3;
  optional string function = 4;
  // URL-ы впервые отправленных док-ов
  repeated string documents_urls = 5;
  // URL-ы изображений для контекста
  repeated string images_urls = 6;
  // Markdown версии документов с сохранением оригинальных имён
  repeated MarkdownUrl markdown_urls = 7;
}

// Отдельный запрос для транскрибации аудио
message TranscribeRequest {
  // Чанк аудиофайла mp3
  bytes mp3_chunk = 1;
  // Опциональная переопределяемая модель распознавания
  optional string speech2text_model = 2;
}

// TranscribeResponseType содержит транскрипцию запроса.
message TranscribeResponseType {
  string transcription = 1;
  float duration = 2;
  float expected_cost_usd = 3;
  // Время завершения транскрибации
  string datetime = 4;
}

// GenerateResponseType содержит данные для промежуточных частей ответа.
message GenerateResponseType {
  optional string content = 1;
  optional string reasoning_content = 2;
  // Время генерации этой части
  string datetime = 3;
}

// CompleteResponseType содержит статистику токенов по завершении генерации.
message CompleteResponseType {
  int32 prompt_tokens = 1;
  int32 completion_tokens = 2;
  int32 total_tokens = 3;
  float expected_cost_usd = 4;
  // Время завершения
  string datetime = 5;
}

// FunctionCallAdded содержит информацию о начале вызова функции.
message FunctionCallAdded {
  string id = 1;     // Уникальный идентификатор вызова функции
  string name = 2;   // Название функции
}

// FunctionCallDelta содержит промежуточные данные при генерации аргументов функции.
message FunctionCallDelta {
  string id = 1;        // Уникальный идентификатор вызова функции
  string content = 2;   // Промежуточная часть аргументов (обычно JSON)
}

// FunctionCallDone содержит завершенные аргументы функции.
message FunctionCallDone {
  string id = 1;          // Уникальный идентификатор вызова функции
  string arguments = 2;   // Полные аргументы функции (JSON)
}

// FunctionCallComplete содержит полную информацию о завершенном вызове функции.
message FunctionCallComplete {
  string id = 1;          // Уникальный идентификатор вызова функции
  string name = 2;        // Название функции
  string arguments = 3;   // Полные аргументы функции (JSON)
}

// ToolMetadataResponse содержит метаданные инструмента.
// Может содержать либо список URL из веб-поиска, либо сгенерированное изображение.
message ToolMetadataResponse {
  oneof metadata {
    // Список URL из результатов веб-поиска
    ToolWebSearchMetadata websearch = 1;
    // Сгенерированное изображение с информацией о стоимости
    ToolImageGenMetadata image_gen = 2;
  }
}

// ToolWebSearchMetadata содержит список URL из веб-поиска.
message ToolWebSearchMetadata {
  repeated string url_list = 1;  // Список URL из результатов поиска
}

// ToolImageGenMetadata содержит сгенерированное изображение.
message ToolImageGenMetadata {
  string image_base64 = 1;      // Изображение в формате Base64
  float expected_cost = 2;      // Ожидаемая стоимость генерации изображения
}

// ChatNameResponseType содержит сгенерированное название чата.
message ChatNameResponseType {
  string name = 1;              // Название чата
  int32 prompt_tokens = 2;
  int32 completion_tokens = 3;
  int32 total_tokens = 4;
  float expected_cost_usd = 5;  // Ожидаемая стоимость генерации названия
}

// MarkdownChunkResponseType содержит часть обработанного markdown документа.
message MarkdownChunkResponseType {
  string markdown_chunk = 1;    // Часть markdown контента
  string original_url = 2;      // URL оригинального документа
  string original_name = 3;     // название оригинального документа
}

// StringsListResponse содержит список доступных моделей.
message StringsListResponse {
  repeated string strings = 1;  // Список названий моделей
}

// NewMessageResponse - ответ от языковой модели при потоковой генерации текста.
// Сервер отправляет множество таких сообщений для одного запроса (stream).
message NewMessageResponse {
  // В теле ответа может быть либо сгенерированный контент (GenerateResponseType),
  // либо финальная информация о завершении (CompleteResponseType), либо информация
  // о вызове функции (FunctionCallAdded/Delta/Done/Complete), либо метаданные инструмента,
  // либо название чата для новых диалогов (ChatNameResponseType), либо обработанная часть
  // markdown документа (MarkdownChunkResponseType).
  oneof response {
    GenerateResponseType generate = 1;
    CompleteResponseType complete = 2;
    FunctionCallAdded function_call_added = 3;
    FunctionCallDelta function_call_delta = 4;
    FunctionCallDone function_call_done = 5;
    FunctionCallComplete function_call_complete = 6;
    ToolMetadataResponse tool_metadata = 7;
    ChatNameResponseType chat_name = 8;
    MarkdownChunkResponseType markdown_chunk = 9;
  }
}

// Отдельный ответ для транскрибации
message TranscribeResponse {
  TranscribeResponseType transcribe = 1;
}

// ============================================================================
// СЕРВИС И RPC-МЕТОДЫ
// ============================================================================

// Service определяет API сервиса - набор удаленных процедур (RPC), которые можно вызвать.
// Это аналог интерфейса в программировании.
service Llm {
  // Ping - простой метод для проверки работоспособности сервиса.
  // Принимает: пустой объект (Empty)
  // Возвращает: пустой объект (Empty)
  // Используется для health-check'ов
  rpc Ping(google.protobuf.Empty) returns (google.protobuf.Empty);

  // NewMessage - метод для отправки сообщения языковой модели и получения ответа.
  // Принимает: одиночный NewMessageRequest.
  // Возвращает: поток (stream) из NewMessageResponse — сервер будет отправлять
  // промежуточные части генерации и финальную статистику по мере готовности.
  rpc NewMessage(NewMessageRequest) returns (stream NewMessageResponse);

  // Transcribe - метод для отправки только аудио и получения транскрипции без генерации
  // Принимает: поток TranscribeRequest с mp3_chunk
  // Возвращает: одиночный TranscribeResponse с результатом транскрибации
  rpc Transcribe(stream TranscribeRequest) returns (TranscribeResponse);

  // AvailableModelsText2Text - получить список доступных Text2Text моделей.
  // Принимает: пустой объект (Empty)
  // Возвращает: StringsListResponse со списком моделей
  rpc AvailableModelsText2Text(google.protobuf.Empty) returns (StringsListResponse);

  // AvailableModelsSpeech2Text - получить список доступных Speech2Text моделей.
  // Принимает: пустой объект (Empty)
  // Возвращает: StringsListResponse со списком моделей
  rpc AvailableModelsSpeech2Text(google.protobuf.Empty) returns (StringsListResponse);

  // AvailableTools - получить список доступных инструментов/функций.
  // Принимает: пустой объект (Empty)
  // Возвращает: StringsListResponse со списком названий инструментов
  rpc AvailableTools(google.protobuf.Empty) returns (StringsListResponse);
}
