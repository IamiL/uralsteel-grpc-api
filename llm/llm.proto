// !!!
// Пришлось изменить логику ответов из-за урезанного openai api Яндекса и
// необходимости совместимости с этим openai api в случае прочих провайдеров инференса.
// А вот прерывание генерации не требует изменений, просто клиенту надо отменить вызов и
// сервис это заметит через контекст.

// Версия синтаксиса Protocol Buffers (используется proto3 - современная версия)
syntax = "proto3";

// Пакет определяет пространство имен для типов данных, определенных в этом файле.
// Это помогает избежать конфликтов имен при использовании нескольких proto-файлов.
package llm;

// Импорт стандартного типа Empty из библиотеки Google Protobuf.
// Empty используется когда RPC-методу не нужно передавать или возвращать данные.
import "google/protobuf/empty.proto";

// Опция для генерации Go-кода: указывает путь к пакету в Go-проекте.
option go_package = "proto/llm";

// ============================================================================
// ПЕРЕЧИСЛЕНИЯ (ENUM)
// ============================================================================

// Перечисление Role определяет роли участников диалога с языковой моделью.
// В proto3 первое значение всегда должно быть 0.
enum Role {
  user = 0;       // Пользователь - человек, задающий вопросы
  assistant = 1;  // Ассистент - языковая модель, отвечающая на вопросы
  system = 2;     // Системная роль - инструкции для поведения модели
  tool = 3;       // Инструмент - ответы от внешних инструментов/функций
}

// ============================================================================
// СТРУКТУРЫ ДАННЫХ (MESSAGE)
// ============================================================================

// Message представляет одно сообщение в диалоге.
// В протобуфах message - это структура данных, аналог struct в Go или class в других языках.
message Message {
  Role  role = 1;    // Роль отправителя сообщения (цифра 1 - это уникальный номер поля)
  string body = 2;   // Текст сообщения (цифра 2 - номер поля, должен быть уникальным в рамках message)
}

// NewMessageRequest - запрос на отправку нового сообщения в чат с языковой моделью.
// Этот тип используется клиентом для передачи данных на сервер.
message NewMessageRequest {
  string  msg = 1;                // Текущее сообщение от пользователя
  repeated Message history = 2;   // История предыдущих сообщений (repeated = массив/список)
                                  // Передается для контекста беседы
}

// GenerateResponseType содержит данные для промежуточных частей ответа.
message GenerateResponseType {
  optional string content = 1;
  optional string reasoning_content = 2;
  // Время генерации этой части
  string datetime = 3;
}

// CompleteResponseType содержит статистику токенов по завершении генерации.
message CompleteResponseType {
  optional int32 prompt_tokens = 1;
  optional int32 completion_tokens = 2;
  optional int32 total_tokens = 3;
  // Время завершения
  string datetime = 4;
}

// NewMessageResponse - ответ от языковой модели при потоковой генерации текста.
// Сервер отправляет множество таких сообщений для одного запроса (stream).
message NewMessageResponse {
  // В теле ответа может быть либо сгенерированный контент (GenerateResponseType),
  // либо финальная информация о завершении (CompleteResponseType).
  oneof response {
    GenerateResponseType generate = 1;
    CompleteResponseType complete = 2;
  }
}

// ============================================================================
// СЕРВИС И RPC-МЕТОДЫ
// ============================================================================

// Service определяет API сервиса - набор удаленных процедур (RPC), которые можно вызвать.
// Это аналог интерфейса в программировании.
service Llm {
  // Ping - простой метод для проверки работоспособности сервиса.
  // Принимает: пустой объект (Empty)
  // Возвращает: пустой объект (Empty)
  // Используется для health-check'ов
  rpc Ping(google.protobuf.Empty) returns (google.protobuf.Empty);

  // NewMessage - метод для отправки сообщения языковой модели и получения ответа.
  // Принимает: NewMessageRequest (сообщение пользователя + история)
  // Возвращает: поток (stream) из NewMessageResponse
  // Ключевое слово "stream" означает, что сервер будет отправлять множество ответов
  // для одного запроса, что позволяет получать текст по мере его генерации.
  rpc NewMessage(NewMessageRequest) returns (stream NewMessageResponse);
}
