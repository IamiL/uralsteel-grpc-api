// !!!
// Пришлось изменить логику ответов из-за урезанного openai api Яндекса и
// необходимости совместимости с этим openai api в случае прочих провайдеров инференса.
// А вот прерывание генерации не требует изменений, просто клиенту надо отменить вызов и
// сервис это заметит через контекст.

// Версия синтаксиса Protocol Buffers (используется proto3 - современная версия)
syntax = "proto3";

// Пакет определяет пространство имен для типов данных, определенных в этом файле.
// Это помогает избежать конфликтов имен при использовании нескольких proto-файлов.
package llm;

// Импорт стандартного типа Empty из библиотеки Google Protobuf.
// Empty используется когда RPC-методу не нужно передавать или возвращать данные.
import "google/protobuf/empty.proto";

// Опция для генерации Go-кода: указывает путь к пакету в Go-проекте.
option go_package = "proto/llm";

// ============================================================================
// ПЕРЕЧИСЛЕНИЯ (ENUM)
// ============================================================================

// Перечисление Role определяет роли участников диалога с языковой моделью.
// В proto3 первое значение всегда должно быть 0.
enum Role {
  user = 0;       // Пользователь - человек, задающий вопросы
  assistant = 1;  // Ассистент - языковая модель, отвечающая на вопросы
  system = 2;     // Системная роль - инструкции для поведения модели
  tool = 3;       // Инструмент - ответы от внешних инструментов/функций
}

// ============================================================================
// СТРУКТУРЫ ДАННЫХ (MESSAGE)
// ============================================================================

// Message представляет одно сообщение в диалоге.
// В протобуфах message - это структура данных, аналог struct в Go или class в других языках.
message Message {
  Role  role = 1;    // Роль отправителя сообщения (цифра 1 - это уникальный номер поля)
  string body = 2;   // Текст сообщения (цифра 2 - номер поля, должен быть уникальным в рамках message)
}

// NewMessageRequest - запрос на отправку нового сообщения в чат с языковой моделью.
// Этот тип используется клиентом для передачи данных на сервер.
// NewMessageRequest - запрос на отправку нового сообщения в чат с языковой моделью.
// Поддерживает два режима передачи:
// 1) Текстовое сообщение — клиент отправляет один пакет с текстом.
// 2) Аудиофайл (строго mp3) — клиент передаёт поток чанков (stream).
// При использовании аудио-потока клиент отправляет несколько сообщений NewMessageRequest,
// каждое из которых содержит поле mp3_chunk с частью байтов файла. Сервер считает все
// чанки, собирает их и при завершении обработки отвечает обычным потоком NewMessageResponse.
message NewMessageRequest {
  // payload — либо текстовое сообщение, либо кусок аудиофайла
  oneof payload {
    // Текстовое сообщение (отправляется в одном пакете)
    string msg = 1;

    // Чанк аудиофайла (может передаваться много раз в потоке)
    bytes mp3_chunk = 2;
  }

  // История предыдущих сообщений (можно передать в первом пакете при отправке аудио,
  // или вместе с текстовым сообщением).
  repeated Message history = 3;
  optional string text2text_model = 4;
  optional string speech2text_model = 5;
  optional string function = 6;
  // URL-ы впервые отправленных док-ов (можно передать в первом пакете при отправке аудио,
  // или вместе с текстовым сообщением).
  repeated string documents_urls = 7;
  // URL-ы изображений для контекста (можно передать в первом пакете при отправке аудио,
  // или вместе с текстовым сообщением).
  repeated string images_urls = 8;
  // URL-ы md док-ов, оригиналы которых помним (можно передать в первом пакете при отправке аудио,
  // или вместе с текстовым сообщением).
  repeated string markdown_urls = 9;
}

// TranscribeResponseType содержит транскрипцию запроса.
message TranscribeResponseType {
  string transcription = 1;
  float duration = 2;
  float expected_cost_usd = 3;
  // Время завершения транскрибации
  string datetime = 4;
}

// GenerateResponseType содержит данные для промежуточных частей ответа.
message GenerateResponseType {
  optional string content = 1;
  optional string reasoning_content = 2;
  // Время генерации этой части
  string datetime = 3;
}

// CompleteResponseType содержит статистику токенов по завершении генерации.
message CompleteResponseType {
  int32 prompt_tokens = 1;
  int32 completion_tokens = 2;
  int32 total_tokens = 3;
  float expected_cost_usd = 4;
  // Время завершения
  string datetime = 5;
}

// FunctionCallAdded содержит информацию о начале вызова функции.
message FunctionCallAdded {
  string id = 1;     // Уникальный идентификатор вызова функции
  string name = 2;   // Название функции
}

// FunctionCallDelta содержит промежуточные данные при генерации аргументов функции.
message FunctionCallDelta {
  string id = 1;        // Уникальный идентификатор вызова функции
  string content = 2;   // Промежуточная часть аргументов (обычно JSON)
}

// FunctionCallDone содержит завершенные аргументы функции.
message FunctionCallDone {
  string id = 1;          // Уникальный идентификатор вызова функции
  string arguments = 2;   // Полные аргументы функции (JSON)
}

// FunctionCallComplete содержит полную информацию о завершенном вызове функции.
message FunctionCallComplete {
  string id = 1;          // Уникальный идентификатор вызова функции
  string name = 2;        // Название функции
  string arguments = 3;   // Полные аргументы функции (JSON)
}

// ToolMetadataResponse содержит метаданные инструмента.
// Может содержать либо список URL из веб-поиска, либо сгенерированное изображение.
message ToolMetadataResponse {
  oneof metadata {
    // Список URL из результатов веб-поиска
    ToolWebSearchMetadata websearch = 1;
    // Сгенерированное изображение с информацией о стоимости
    ToolImageGenMetadata image_gen = 2;
  }
}

// ToolWebSearchMetadata содержит список URL из веб-поиска.
message ToolWebSearchMetadata {
  repeated string url_list = 1;  // Список URL из результатов поиска
}

// ToolImageGenMetadata содержит сгенерированное изображение.
message ToolImageGenMetadata {
  string image_base64 = 1;      // Изображение в формате Base64
  float expected_cost = 2;      // Ожидаемая стоимость генерации изображения
}

// ChatNameResponseType содержит сгенерированное название чата.
message ChatNameResponseType {
  string name = 1;              // Название чата
  float expected_cost_usd = 2;  // Ожидаемая стоимость генерации названия
}

// MarkdownChunkResponseType содержит часть обработанного markdown документа.
message MarkdownChunkResponseType {
  string markdown_chunk = 1;    // Часть markdown контента
  string original_url = 2;      // URL оригинального документа
}

// StringsListResponse содержит список доступных моделей.
message StringsListResponse {
  repeated string strings = 1;  // Список названий моделей
}

// NewMessageResponse - ответ от языковой модели при потоковой генерации текста.
// Сервер отправляет множество таких сообщений для одного запроса (stream).
message NewMessageResponse {
  // В теле ответа может быть либо сгенерированный контент (GenerateResponseType),
  // либо финальная информация о завершении (CompleteResponseType), либо информация
  // о вызове функции (FunctionCallAdded/Delta/Done/Complete), либо метаданные инструмента,
  // либо название чата для новых диалогов (ChatNameResponseType), либо обработанная часть
  // markdown документа (MarkdownChunkResponseType).
  oneof response {
    TranscribeResponseType transcribe = 1;
    GenerateResponseType generate = 2;
    CompleteResponseType complete = 3;
    FunctionCallAdded function_call_added = 4;
    FunctionCallDelta function_call_delta = 5;
    FunctionCallDone function_call_done = 6;
    FunctionCallComplete function_call_complete = 7;
    ToolMetadataResponse tool_metadata = 8;
    ChatNameResponseType chat_name = 9;
    MarkdownChunkResponseType markdown_chunk = 10;
  }
}

// ============================================================================
// СЕРВИС И RPC-МЕТОДЫ
// ============================================================================

// Service определяет API сервиса - набор удаленных процедур (RPC), которые можно вызвать.
// Это аналог интерфейса в программировании.
service Llm {
  // Ping - простой метод для проверки работоспособности сервиса.
  // Принимает: пустой объект (Empty)
  // Возвращает: пустой объект (Empty)
  // Используется для health-check'ов
  rpc Ping(google.protobuf.Empty) returns (google.protobuf.Empty);

  // NewMessage - метод для отправки сообщения языковой модели и получения ответа.
  // Принимает: поток из NewMessageRequest — это позволяет передавать либо одно
  // текстовое сообщение, либо поток чанков аудиофайла (для больших mp3).
  // Возвращает: поток (stream) из NewMessageResponse — сервер будет отправлять
  // промежуточные части генерации и финальную статистику по мере готовности.
  rpc NewMessage(stream NewMessageRequest) returns (stream NewMessageResponse);

  // AvailableModelsText2Text - получить список доступных Text2Text моделей.
  // Принимает: пустой объект (Empty)
  // Возвращает: StringsListResponse со списком моделей
  rpc AvailableModelsText2Text(google.protobuf.Empty) returns (StringsListResponse);

  // AvailableModelsSpeech2Text - получить список доступных Speech2Text моделей.
  // Принимает: пустой объект (Empty)
  // Возвращает: StringsListResponse со списком моделей
  rpc AvailableModelsSpeech2Text(google.protobuf.Empty) returns (StringsListResponse);

  // AvailableTools - получить список доступных инструментов/функций.
  // Принимает: пустой объект (Empty)
  // Возвращает: StringsListResponse со списком названий инструментов
  rpc AvailableTools(google.protobuf.Empty) returns (StringsListResponse);
}
